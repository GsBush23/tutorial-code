\import Indexed

-- 1. Implement the function 'lookup', which takes a list and a natural number n and returns the n-th element in the list.
--    Note that it is impossible to define such a function without restrictions on n sice n can be greater than the size of the list.
--    Therefore the function should also take a proof that n is in the right range: T (n < length xs).

\func length {A : \Type} (xs : List A) : Nat
  | nil => 0
  | cons _ xs => suc (length xs)

\func lookup {A : \Type} (xs : List A) (n : Nat) (p : T (n < length xs)) : A
  | nil, 0, ()
  | nil, suc _, ()
  | cons x _, 0, _ => x
  | cons _ xs, suc n, p => lookup xs n p

-- 2. Implement function replicate for 'vec' and 'Vec' (this function creates the list of a given length filled with a
-- given element).

\func replicate {A : \Type} (n : Nat) (x : A) : Vec A n \elim n
  | 0 => fnil
  | suc n => fcons x (replicate n x)

-- 3. Implement function 'map' for 'vec' and 'Vec'.

\func map {A B : \Type} {n : Nat} (f : A -> B) (xs : Vec A n) : Vec B n \elim n, xs
  | 0, fnil => fnil
  | suc n, fcons x xs => fcons (f x) (map f xs)

-- 4. Implement function 'zipWith' for 'vec' and 'Vec'.
--    The function must take lists of equal lengths.

\func zipWith {A B C : \Type} {n : Nat} (f : A -> B -> C) (xs : Vec A n) (ys : Vec B n)
  : Vec C n \elim n, xs, ys
  | 0, fnil, fnil => fnil
  | suc n, fcons x xs, fcons y ys => fcons (f x y) (zipWith f xs ys)

-- 5. Functions Fin n -> A correspond to lists of length n with elements in A.
--    Implement the function that converts an element of Fin n -> A to element of Vec A n.

\func funToVec {A : \Type} {n : Nat} (f : Fin n -> A) : Vec A n \elim n
  | 0 => fnil
  | suc _ => fcons (f fzero) (funToVec (\lam x => f (fsuc x)))

-- 6. Define the type of matrices and a number of functions for them:

\func Mat (A : \Type) (n m : Nat) : \Type
  => Fin n -> Fin m -> A

-- diagonal matrix with elements e on the diagonal and z at all other positions.

\func \infix 4 == {n : Nat} (x y : Fin n) : Bool
  | {suc _}, fzero, fzero => true
  | {suc _}, fsuc x, fsuc y => x == y
  | {suc _}, _, _ => false

\func diag {A : \Type} (z e : A) (n : Nat) : Mat A n n
  => \lam x y => if (x == y) e z

\func diag2x2 => diag 0 1 2
\func testDiag2x2 : diag2x2 fzero fzero = 1 => idp
\func testDiag2x2' : diag2x2 (fsuc fzero) fzero = 0 => idp

-- transposition

\func transpose {A : \Type} {n m : Nat} (M : Mat A n m) : Mat A m n
  => \lam x y => M y x

-- addition

\func matAdd {A : \Type} (add : A -> A -> A) (n m : Nat) (M N : Mat A n m) : Mat A n m
  => \lam x y => add (M x y) (N x y)

-- multiplication

-- z is neutral under addition.

\func foldl {A B : \Type} {n : Nat} (f : A -> B -> A) (acc : A) (xs : Vec B n) : A \elim n, xs
  | 0, fnil => acc
  | suc n, fcons x xs => foldl f (f acc x) xs

\func matMul {A : \Type} (z : A) (add mul : A -> A -> A) (n m k : Nat) (M : Mat A n m) (N : Mat A m k)
  : Mat A n k
  => \lam x y => \let p => zipWith (__, __) (funToVec (M x)) (funToVec ((transpose N) y))
                 \in foldl (\lam x y => add x (mul y.1 y.2)) z p

-- 7. Define the type CTree A n of (complete and full) binary trees of height precisely n, which store elements in internal nodes, but not in leaves.
--    The height of a leaf is 0.

\data CTree (A : \Type) (n : Nat) \elim n
  | 0 => emptyCTree
  | suc n => nodeCTree A (CTree A n) (CTree A n)

-- 8. Define the type Tree A n of binary trees of height at most n, which store elements in internal nodes, but not in leaves.
--    The height of a leaf is 0.

\data Tree (A : \Type) (n : Nat) \elim n
  | _ => emptyTree
  | suc n => nodeTree A (Tree A n) (Tree A n)

-- Define the function that computes the height of a tree.

\func height {A : \Type} (n : Nat) (t : Tree A n) : Fin (suc n)
  | _, emptyTree => fzero
  | suc n, nodeTree a t1 t2 => fsuc (maxFin (height n t1) (height n t2))
  \where
    \func maxFin {n : Nat} (x y : Fin n) : Fin n
      | {suc _}, fzero, y => y
      | {suc _}, x, fzero => x
      | {suc _}, fsuc x, fsuc y => fsuc (maxFin x y)
