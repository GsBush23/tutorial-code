-- 1. Define priorities of the functions f1, f2, f3, f4, f5 and f6 so that the function 'test' typechecks.

\func f1 (x y : Nat) => x
\func f2 : Nat => 0
\func \infix 4 f3 (f : Nat -> Nat) (z : Nat) : Int => 0
\func f4 : Nat => 0
\func \infix 5 f5 => f1
\func f6 => f4

\func test => f1 f2 f3 f4 f5 f6

-- 2. Define in Arend the function 'if', which takes a boolean value b and two elements of an arbitrary type A
--    and return the first element when b equals to true and the second one otherwise.

\data Bool | true | false

\func if {A : \Type} (b : Bool) (x y : A) : A \elim b
  | true => x
  | false => y

-- 3. Define || via 'if'.

\func \infixr 2 || (x y : Bool) : Bool => if x y false

-- 4. Define the power and the factorial functions for natural numbers.

\func \infixl 6 + (x y : Nat) : Nat \elim y
  | 0 => x
  | suc y => suc (x + y)

\func \infixl 7 * (x y : Nat) : Nat \elim y
  | 0 => 0
  | suc y => x * y + x

\func \infixr 8 ^ (x y : Nat) : Nat \elim y
  | 0 => 1
  | suc y => x ^ y * x

\func fac (x : Nat) : Nat
  | 0 => 1
  | suc x => fac x * suc x

\func test^ : 2 ^ 5 = 32 => idp
\func testFac : fac 5 = 120 => idp

-- 5. Define mod and gcd.

\func \infixl 6 - (x y : Nat) : Nat
  | 0, _ => 0
  | suc x, 0 => suc x
  | suc x, suc y => x - y

\func \infix 4 < (x y : Nat) : Bool
  | 0, 0 => false
  | 0, suc y => true
  | suc x, 0 => false
  | suc x, suc y => x < y

\func mod (x y : Nat) : Nat => mod' x x y
  \where
    \func mod' (s x y : Nat) : Nat \elim s
      | 0 => 0
      | suc s => if (x < y) x (mod' s (x - y) y)

\func gcd (x y : Nat) => gcd' x x y
  \where
    \func gcd' (s x y : Nat) : Nat \elim s, y
      | _, 0 => x
      | 0, y => y
      | suc s, y => gcd' s y (mod x y)

\func testMod0 : mod 0 7 = 0 => idp
\func testMod1 : mod 23 6 = 5 => idp
\func testMod2 : mod 6 23 = 6 => idp

\func testGcd0 : gcd 0 7 = 7 => idp
\func testGcd1 : gcd 7 0 = 7 => idp
\func testGcd2 : gcd 6 23 = 1 => idp
\func testGcd3 : gcd 45 12 = 3 => idp

-- 6. Define the map function.

\data List (A : \Type) | nil | \infixr 5 :: A (List A)

\func map {A B : \Type} (f : A -> B) (xs : List A) : List B \elim xs
  | nil => nil
  | :: x xs => f x :: map f xs

-- 7. Define the transpose function.
--    It takes a list of lists considered as a matrix and returns a list of lists which represents the transposed matrix.
--    Example:
--    transpose ((1 :: 2 :: 3 :: nil) :: (4 :: 5 :: 6 :: nil) :: nil) == ((1 :: 4 :: nil) :: (2 :: 5 :: nil) :: (3 :: 6 :: nil) :: nil)

\func heads {A : \Type} (xs : List (List A)) : List A
  | nil => nil
  | :: nil xs => heads xs
  | :: (:: x _) xs => x :: heads xs

\func tail {A : \Type} (xs : List A) : List A
  | nil => nil
  | :: x xs => xs

\func transpose {A : \Type} (xs : List (List A)) : List (List A)
  | nil => nil
  | :: nil xs => transpose xs
  | :: (:: x xs) xss => (x :: heads xss) :: transpose (xs :: (map tail xss))

\func testTranspose0 : transpose ((0 :: nil) :: (1 :: nil) :: nil)
  = ((0 :: 1 :: nil) :: nil)
  => idp

\func testTranspose1 : transpose ((1 :: 2 :: 3 :: nil) :: (4 :: 5 :: 6 :: nil) :: nil)
  = ((1 :: 4 :: nil) :: (2 :: 5 :: nil) :: (3 :: 6 :: nil) :: nil)
  => idp
